# 1. 넘파이 라이브러리 가져오기(import)

* ```벡터 Vector``` 또는 ```행렬 Matrix```를 계산하기 위한 파이썬 라이브러리
* ```import numpy as np```

</br>

# 2. Numpy vs List

* 리스트 간의 덧셈 결과는, 행렬의 덧셈 결과가 아니라, 원소 값들이 ```추가 Append```됨
* 머신러닝과 딥러닝을 구현할 때, 다양한 행렬 연산을 하려면 우선 ```넘파이 numpy```로 행렬을 만들어야 한다.

</br>

# 3. 넘파이 벡터(Vector, 1차원 배열) 생성

* ```np.array()```는 파이썬의 ```리스트 list```를 ```인수```로 받아서 넘파이가 제공하는 ```특수한 배열 형태```인 ```numpy.ndarray 타입```을 리턴한다.
* ```벡터```의 ```형상 Shape```과 ```차원 Dimension```은 넘파이의 ```shape```와 ```ndim``` 속성을 이용
 
</br>

# 4. 넘파이 행렬(Matrix, 2차원 배열) 생성

* 백터를 만들 때와는 다르게, ```행렬```에서 1개 ```행 Row```을 정의하려면 ```np.array() 메서드``` 안에서 다시 ```대괄호```를 사용

</br>

# 5. 넘파이 산술연산

* ```벡터 또는 행렬의 산술연산```을 하려면 ```대응되는 원소의 개수가 반드시 같아야``` 한다.

</br>

# 6 넘파이 형 변환(reshape)

* 머신러닝 코드를 구현할 때 넘파이 ```백터```를 ```행렬```로 변경하거나, ```행렬```을 다시 ```다른 형상 shape의 행렬```로 변경해야 하는 경우가 많은데, 넘파이의 ```rehape() 메서드```를 사용한면 ```형상 shape```을 손쉽게 변경 가능
* ```reshape() 메서드```의 ```첫 번째 인수```로 ```-1```이 오는 경우, 예를 들어, ```reshape(-1, XXX)```는 ```reshape(-1, XXX) 메서드```의 ```두 번째 인수 XXX 값```으로 ```주어지는 열 Column```을 가지는 ```행렬 Matrix```로 ```형 변환```하라는 의미

</br>

# 7. 넘파이 브로드캐스트(Broadcast)

* 행렬의 사칙연산은 기본적으로 두 행렬의 크기가 서로 같은 경우에만 가능
* 그러나 넘파이에는 ```크기가 다른 두 행렬도 사칙연산이 가능하도록 확장하는 기능```이 있는데, 이를 ```브로드캐스트 Broadcast```라고 한다.
* 차원이 작은 쪽이, 큰 쪽에 맞추어 행 단위로, 반복적으로 크기를 확장하는 기능
* 단, ```브로드캐스트 Broadcast```는 ```행렬 곱 연산에는 적용되지 않고```, ```오로지 사칙연산에만 가능하다```는 것을 반드시 기억

</br>

# 8. 넘파이 전치행렬(Transpose)

* 원본 행렬의 ```열은 행으로```, ```행은 열로 바꾼 것```을, ```전치행렬 Transpose Matrix```라고 한다.
* 넘파이에서는 ```T연산자```를 이용
* 주의해야 할 것은, ```벡터 Vector```를 ```전치행렬```로 만들 경우, 결과도 ```계속 벡터 Vector로 남는다```는 것
* ```벡터 Vector```를 ```행렬```로 ```전치```하고자 한다면, ```reshape()```를 이용해서 강제로 행렬로 변환해줘야 한다.

</br>

# 9. 넘파이 행렬 곱(Matrix Multiplication)

* 넘파이에서 행렬 A와 B의 ```행렬 곱 Matrix Multiplication```은 ```np.dot(A, B)```와 같이 나타내고, ```앞의 행렬 A의 열 Column```과 ```뒤에 오는 행렬 B의 행 Row```이 ```같아야만``` 행렬 곱 계산 가능

</br>

# 10. 행렬 원소 접근(Indexing, Slicing)

* 행렬의 원소에 접근할 경우, 대괄호 안에서 ```콤마(,)```를 기준으로 ```왼쪽```은 ```행 Row```, ```오른쪽```은 ```열 Column```을 나타낸다.

</br>

# 11. 넘파이 이터레이터(Iterator)

* 행렬의 모든 원소를 처음부터 끝까지 하나씩 가져오기 위함
* ```C++, Java```에서의 ```이터레이터 Iterator```처럼 ```next 메서드```를 통해서 데이터의 처음부터 끝까지 순차적으로 읽어 들이는 방법 제공
* ```flags=['multi_indx']```는 이터레이터를 생성 후, 반복할 때, 행렬처럼 ```(행,열) 형태```를 가지는 ```multi_index 형태```로 동작하라는 의미
* ```op_flags=['readwrite']``` 코드는 이터레이터를 ```Read/Write 형태```로 생성
</br>

# 12. 넘파이 유용한 함수(Useful Function)

## 12.1 concatenate()

* 행렬에 ```행 Row```, 또는 ```열 Column``` ```추가하기```
* 머신러닝의 ```회귀 Regression``` 코드 구현시, ```가중치 weight```와 ```바이어스 bias```를 별도로 구분하지 않고, ```하나의 행렬```로 취급하기 위한 프로그래밍 구현 기술

</br>

## 12.2 np.random.rand()

* ```0```과 ```1```사이의 ```임의의 실수 값```을 얻고자 할 때, 사용하는 넘파이 함수

</br>

## 12.3 np.max(), np.argmax() 함수

* ```np.max()``` : ```벡터나 행렬의 최댓값```을 알기 위한 함수
* ```np.argmax()``` : ```최댓값을 가지는 인덱스```를 찾아 주는 함수, 차후에 딥러닝 구조에서 ```원핫 인코딩 One-Hot Encoding``` 방식을 적용할 때, 필요한 함수

</br>

## 12.4 np.loadtxt() 함수

* 분리자로 구분된 파일에서 데이터를 읽어와서 행렬로 리턴해 주는 함수
* ```첫 번째 인수```는 읽어 들이는 파일의 ```경로 Path```, ```두 번째 인수```는 ```분리자 Delimeter```, 즉 파일이 어떤 분리자로 분리되어 있는지, ```세 번째 인수```는 읽어 들일 ```데이터 타입```, 일반적으로 ```실수(np.float32)```

</br>
